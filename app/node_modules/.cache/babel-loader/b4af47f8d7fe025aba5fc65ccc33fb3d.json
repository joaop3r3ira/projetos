{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { generatePrivate, getPublic, decrypt } from '@toruslabs/eccrypto';\nimport { post, generateJsonRPCObject, setAPIKey, setEmbedHost, get } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport JsonStringify from 'json-stable-stringify';\nimport { toChecksumAddress } from 'web3-utils';\nimport loglevel from 'loglevel';\nimport createKeccakHash from 'keccak';\nconst log = loglevel.getLogger(\"torus.js\");\nlog.disableAll();\n\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nclass SomeError extends Error {\n  constructor(_ref) {\n    let {\n      errors,\n      responses,\n      predicate\n    } = _ref;\n    super(\"Unable to resolve enough promises.\");\n\n    _defineProperty(this, \"errors\", void 0);\n\n    _defineProperty(this, \"responses\", void 0);\n\n    _defineProperty(this, \"predicate\", void 0);\n\n    this.errors = errors;\n    this.responses = responses;\n    this.predicate = predicate;\n  }\n\n}\n\nconst Some = (promises, predicate) => new Promise((resolve, reject) => {\n  let finishedCount = 0;\n  const sharedState = {\n    resolved: false\n  };\n  const errorArr = new Array(promises.length).fill(undefined);\n  const resultArr = new Array(promises.length).fill(undefined);\n  let predicateError;\n  return promises.forEach((x, index) => {\n    return x.then(resp => {\n      resultArr[index] = resp;\n      return undefined;\n    }).catch(error => {\n      errorArr[index] = error;\n    }) // eslint-disable-next-line promise/no-return-in-finally\n    .finally(() => {\n      if (sharedState.resolved) return;\n      return predicate(resultArr.slice(0), sharedState).then(data => {\n        sharedState.resolved = true;\n        resolve(data);\n        return undefined;\n      }).catch(error => {\n        // log only the last predicate error\n        predicateError = error;\n      }).finally(() => {\n        finishedCount += 1;\n\n        if (finishedCount === promises.length) {\n          const errors = Object.values(resultArr.reduce((acc, z) => {\n            if (z) {\n              var _error$data;\n\n              const {\n                id,\n                error\n              } = z;\n\n              if ((error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {\n                if (error.data.startsWith(\"Error occurred while verifying params\")) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;\n              }\n            }\n\n            return acc;\n          }, {}));\n\n          if (errors.length > 0) {\n            // Format-able errors\n            const msg = errors.length > 1 ? `\\n${errors.map(it => `â€¢ ${it}`).join(\"\\n\")}` : errors[0];\n            reject(new Error(msg));\n          } else {\n            var _predicateError;\n\n            reject(new SomeError({\n              errors: errorArr,\n              responses: resultArr,\n              predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError\n            }));\n          }\n        }\n      });\n    });\n  });\n});\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass GetOrSetNonceError extends Error {}\n\nconst kCombinations = (s, k) => {\n  let set = s;\n\n  if (typeof set === \"number\") {\n    set = Array.from({\n      length: set\n    }, (_, i) => i);\n  }\n\n  if (k > set.length || k <= 0) {\n    return [];\n  }\n\n  if (k === set.length) {\n    return [set];\n  }\n\n  if (k === 1) {\n    return set.reduce((acc, cur) => [...acc, [cur]], []);\n  }\n\n  const combs = [];\n  let tailCombs = [];\n\n  for (let i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1);\n\n    for (let j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i], ...tailCombs[j]]);\n    }\n  }\n\n  return combs;\n};\n\nconst thresholdSame = (arr, t) => {\n  const hashMap = {};\n\n  for (let i = 0; i < arr.length; i += 1) {\n    const str = JsonStringify(arr[i]);\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;\n\n    if (hashMap[str] === t) {\n      return arr[i];\n    }\n  }\n\n  return undefined;\n};\n\nconst keyLookup = async (endpoints, verifier, verifierId) => {\n  const lookupPromises = endpoints.map(x => post(x, generateJsonRPCObject(\"VerifierLookupRequest\", {\n    verifier,\n    verifier_id: verifierId.toString()\n  })).catch(err => log.error(\"lookup request failed\", err)));\n  return Some(lookupPromises, lookupResults => {\n    const lookupShares = lookupResults.filter(x1 => x1);\n    const errorResult = thresholdSame(lookupShares.map(x2 => x2 && x2.error), ~~(endpoints.length / 2) + 1);\n    const keyResult = thresholdSame(lookupShares.map(x3 => x3 && x3.result), ~~(endpoints.length / 2) + 1);\n\n    if (keyResult || errorResult) {\n      return Promise.resolve({\n        keyResult,\n        errorResult\n      });\n    }\n\n    return Promise.reject(new Error(`invalid results ${JSON.stringify(lookupResults)}`));\n  });\n};\n\nconst waitKeyLookup = (endpoints, verifier, verifierId, timeout) => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject);\n  }, timeout);\n});\n\nconst keyAssign = async _ref => {\n  let {\n    endpoints,\n    torusNodePubs,\n    lastPoint,\n    firstPoint,\n    verifier,\n    verifierId,\n    signerHost,\n    network\n  } = _ref;\n  let nodeNum;\n  let initialPoint;\n\n  if (lastPoint === undefined) {\n    nodeNum = Math.floor(Math.random() * endpoints.length);\n    initialPoint = nodeNum;\n  } else {\n    nodeNum = lastPoint % endpoints.length;\n  }\n\n  if (nodeNum === firstPoint) throw new Error(\"Looped through all\");\n  if (firstPoint !== undefined) initialPoint = firstPoint;\n  const data = generateJsonRPCObject(\"KeyAssign\", {\n    verifier,\n    verifier_id: verifierId.toString()\n  });\n\n  try {\n    const signedData = await post(signerHost, data, {\n      headers: {\n        pubKeyX: torusNodePubs[nodeNum].X,\n        pubKeyY: torusNodePubs[nodeNum].Y,\n        network\n      }\n    }, {\n      useAPIKey: true\n    });\n    return await post(endpoints[nodeNum], _objectSpread$1(_objectSpread$1({}, data), signedData), {\n      headers: {\n        \"Content-Type\": \"application/json; charset=utf-8\"\n      }\n    });\n  } catch (error) {\n    log.error(error);\n    const acceptedErrorMsgs = [// Slow node\n    \"Timed out\", // Happens when the node is not reachable (dns issue etc)\n    \"TypeError: Failed to fetch\", \"TypeError: cancelled\", \"TypeError: NetworkError when attempting to fetch resource.\" // Firefox\n    ];\n    if (acceptedErrorMsgs.includes(error.message)) return keyAssign({\n      endpoints,\n      torusNodePubs,\n      lastPoint: nodeNum + 1,\n      firstPoint: initialPoint,\n      verifier,\n      verifierId,\n      signerHost,\n      network\n    });\n    throw new Error(`Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \\n\n    ${error.message || \"\"}`);\n  }\n};\n\nfunction keccak256(a) {\n  const hash = createKeccakHash(\"keccak256\").update(a).digest().toString(\"hex\");\n  return `0x${hash}`;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n} // of Torus nodes to handle malicious node responses\n\n\nclass Torus {\n  constructor() {\n    let {\n      enableOneKey = false,\n      metadataHost = \"https://metadata.tor.us\",\n      allowHost = \"https://signer.tor.us/api/allow\",\n      signerHost = \"https://signer.tor.us/api/sign\",\n      serverTimeOffset = 0,\n      network = \"mainnet\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _defineProperty(this, \"metadataHost\", void 0);\n\n    _defineProperty(this, \"allowHost\", void 0);\n\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n\n    _defineProperty(this, \"enableOneKey\", void 0);\n\n    _defineProperty(this, \"signerHost\", void 0);\n\n    _defineProperty(this, \"network\", void 0);\n\n    _defineProperty(this, \"ec\", void 0);\n\n    this.ec = new ec(\"secp256k1\");\n    this.metadataHost = metadataHost;\n    this.allowHost = allowHost;\n    this.enableOneKey = enableOneKey;\n    this.serverTimeOffset = serverTimeOffset || 0; // ms\n\n    this.signerHost = signerHost;\n    this.network = network;\n  }\n\n  static enableLogging() {\n    let v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (v) log.enableAll();else log.disableAll();\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n\n  static isGetOrSetNonceError(err) {\n    return err instanceof GetOrSetNonceError;\n  }\n  /**\n   * Note: use this function only for openlogin tkey account lookups.\n   */\n\n\n  async getUserTypeAndAddress(endpoints, torusNodePubs, _ref) {\n    let {\n      verifier,\n      verifierId\n    } = _ref;\n    let doesKeyAssign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      keyResult,\n      errorResult\n    } = (await keyLookup(endpoints, verifier, verifierId)) || {};\n    let isNewKey = false;\n    let finalKeyResult;\n\n    if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n      if (!doesKeyAssign) {\n        throw new Error(\"Verifier + VerifierID has not yet been assigned\");\n      }\n\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network\n      });\n      const assignResult = await waitKeyLookup(endpoints, verifier, verifierId, 1000);\n      finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n      isNewKey = true;\n    } else if (keyResult) {\n      finalKeyResult = keyResult;\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n\n    if (finalKeyResult) {\n      const {\n        pub_key_X: X,\n        pub_key_Y: Y\n      } = finalKeyResult.keys[0];\n      let nonceResult;\n      let nonce;\n      let modifiedPubKey;\n\n      try {\n        nonceResult = await this.getOrSetNonce(X, Y, undefined, !isNewKey);\n        nonce = new BN(nonceResult.nonce || \"0\", 16);\n      } catch {\n        throw new GetOrSetNonceError();\n      }\n\n      if (nonceResult.typeOfUser === \"v1\") {\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n      } else if (nonceResult.typeOfUser === \"v2\") {\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPublic({\n          x: nonceResult.pubNonce.x,\n          y: nonceResult.pubNonce.y\n        }).getPublic());\n      } else {\n        throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n      }\n\n      const finalX = modifiedPubKey.getX().toString(16);\n      const finalY = modifiedPubKey.getY().toString(16);\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n      if (nonceResult.typeOfUser === \"v1\") return {\n        typeOfUser: nonceResult.typeOfUser,\n        nonce,\n        X: finalX,\n        Y: finalY,\n        address\n      };else if (nonceResult.typeOfUser === \"v2\") {\n        return {\n          typeOfUser: nonceResult.typeOfUser,\n          nonce,\n          pubNonce: nonceResult.pubNonce,\n          upgraded: nonceResult.upgraded,\n          X: finalX,\n          Y: finalY,\n          address\n        };\n      }\n    }\n\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n  }\n\n  async setCustomKey(_ref2) {\n    let {\n      privKeyHex,\n      metadataNonce,\n      torusKeyHex,\n      customKeyHex\n    } = _ref2;\n    let torusKey;\n\n    if (torusKeyHex) {\n      torusKey = new BN(torusKeyHex, 16);\n    } else {\n      const privKey = new BN(privKeyHex, 16);\n      torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n);\n    }\n\n    const customKey = new BN(customKeyHex, 16);\n    const newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n);\n    const data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey);\n    await this.setMetadata(data);\n  }\n\n  async retrieveShares(endpoints, indexes, verifier, verifierParams, idToken) {\n    let extraParams = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    const promiseArr = [];\n    await get(this.allowHost, {\n      headers: {\n        verifier,\n        verifier_id: verifierParams.verifier_id,\n        network: this.network\n      }\n    }, {\n      useAPIKey: true\n    });\n    /*\n      CommitmentRequestParams struct {\n        MessagePrefix      string `json:\"messageprefix\"`\n        TokenCommitment    string `json:\"tokencommitment\"`\n        TempPubX           string `json:\"temppubx\"`\n        TempPubY           string `json:\"temppuby\"`\n        VerifierIdentifier string `json:\"verifieridentifier\"`\n      }\n      */\n    // generate temporary private and public key that is used to secure receive shares\n\n    const tmpKey = generatePrivate();\n    const pubKey = getPublic(tmpKey).toString(\"hex\");\n    const pubKeyX = pubKey.slice(2, 66);\n    const pubKeyY = pubKey.slice(66);\n    const tokenCommitment = keccak256(idToken); // make commitment requests to endpoints\n\n    for (let i = 0; i < endpoints.length; i += 1) {\n      const p = post(endpoints[i], generateJsonRPCObject(\"CommitmentRequest\", {\n        messageprefix: \"mug00\",\n        tokencommitment: tokenCommitment.slice(2),\n        temppubx: pubKeyX,\n        temppuby: pubKeyY,\n        verifieridentifier: verifier\n      })).catch(err => {\n        log.error(\"commitment\", err);\n      });\n      promiseArr.push(p);\n    }\n    /*\n      ShareRequestParams struct {\n        Item []bijson.RawMessage `json:\"item\"`\n      }\n      ShareRequestItem struct {\n        IDToken            string          `json:\"idtoken\"`\n        NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n        VerifierIdentifier string          `json:\"verifieridentifier\"`\n      }\n      NodeSignature struct {\n        Signature   string\n        Data        string\n        NodePubKeyX string\n        NodePubKeyY string\n      }\n      CommitmentRequestResult struct {\n        Signature string `json:\"signature\"`\n        Data      string `json:\"data\"`\n        NodePubX  string `json:\"nodepubx\"`\n        NodePubY  string `json:\"nodepuby\"`\n      }\n      */\n    // send share request once k + t number of commitment requests have completed\n\n\n    return Some(promiseArr, resultArr => {\n      const completedRequests = resultArr.filter(x => {\n        if (!x || typeof x !== \"object\") {\n          return false;\n        }\n\n        if (x.error) {\n          return false;\n        }\n\n        return true;\n      });\n\n      if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n        return Promise.resolve(resultArr);\n      }\n\n      return Promise.reject(new Error(`invalid ${JSON.stringify(resultArr)}`));\n    }).then(responses => {\n      const promiseArrRequest = [];\n      const nodeSigs = [];\n\n      for (let i = 0; i < responses.length; i += 1) {\n        if (responses[i]) nodeSigs.push(responses[i].result);\n      }\n\n      for (let i = 0; i < endpoints.length; i += 1) {\n        // eslint-disable-next-line promise/no-nesting\n        const p = post(endpoints[i], generateJsonRPCObject(\"ShareRequest\", {\n          encrypted: \"yes\",\n          item: [_objectSpread(_objectSpread({}, verifierParams), {}, {\n            idtoken: idToken,\n            nodesignatures: nodeSigs,\n            verifieridentifier: verifier\n          }, extraParams)]\n        })).catch(err => log.error(\"share req\", err));\n        promiseArrRequest.push(p);\n      }\n\n      return Some(promiseArrRequest, async (shareResponses, sharedState) => {\n        /*\n            ShareRequestResult struct {\n              Keys []KeyAssignment\n            }\n                    / KeyAssignmentPublic -\n            type KeyAssignmentPublic struct {\n              Index     big.Int\n              PublicKey common.Point\n              Threshold int\n              Verifiers map[string][]string // Verifier => VerifierID\n            }\n                   // KeyAssignment -\n            type KeyAssignment struct {\n              KeyAssignmentPublic\n              Share big.Int // Or Si\n            }\n          */\n        // check if threshold number of nodes have returned the same user public key\n        const completedRequests = shareResponses.filter(x => x);\n        const thresholdPublicKey = thresholdSame(shareResponses.map(x => x && x.result && x.result.keys[0].PublicKey), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received\n        // this is matched against the user public key to ensure that shares are consistent\n\n        if (completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey) {\n          const sharePromises = [];\n          const nodeIndexes = [];\n\n          for (let i = 0; i < shareResponses.length; i += 1) {\n            var _currentShareResponse, _currentShareResponse2;\n\n            const currentShareResponse = shareResponses[i];\n\n            if ((currentShareResponse === null || currentShareResponse === void 0 ? void 0 : (_currentShareResponse = currentShareResponse.result) === null || _currentShareResponse === void 0 ? void 0 : (_currentShareResponse2 = _currentShareResponse.keys) === null || _currentShareResponse2 === void 0 ? void 0 : _currentShareResponse2.length) > 0) {\n              currentShareResponse.result.keys.sort((a, b) => new BN(a.Index, 16).cmp(new BN(b.Index, 16)));\n              const firstKey = currentShareResponse.result.keys[0];\n\n              if (firstKey.Metadata) {\n                const metadata = {\n                  ephemPublicKey: Buffer.from(firstKey.Metadata.ephemPublicKey, \"hex\"),\n                  iv: Buffer.from(firstKey.Metadata.iv, \"hex\"),\n                  mac: Buffer.from(firstKey.Metadata.mac, \"hex\") // mode: Buffer.from(firstKey.Metadata.mode, \"hex\"),\n\n                };\n                sharePromises.push( // eslint-disable-next-line promise/no-nesting\n                decrypt(tmpKey, _objectSpread(_objectSpread({}, metadata), {}, {\n                  ciphertext: Buffer.from(Buffer.from(firstKey.Share, \"base64\").toString(\"binary\").padStart(64, \"0\"), \"hex\")\n                })).catch(err => log.debug(\"share decryption\", err)));\n              } else {\n                sharePromises.push(Promise.resolve(Buffer.from(firstKey.Share.padStart(64, \"0\"), \"hex\")));\n              }\n            } else {\n              sharePromises.push(Promise.resolve(undefined));\n            }\n\n            nodeIndexes.push(new BN(indexes[i], 16));\n          }\n\n          const sharesResolved = await Promise.all(sharePromises);\n          if (sharedState.resolved) return undefined;\n          const decryptedShares = sharesResolved.reduce((acc, curr, index) => {\n            if (curr) acc.push({\n              index: nodeIndexes[index],\n              value: new BN(curr)\n            });\n            return acc;\n          }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n\n          const allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);\n          let privateKey = null;\n\n          for (let j = 0; j < allCombis.length; j += 1) {\n            const currentCombi = allCombis[j];\n            const currentCombiShares = decryptedShares.filter((v, index) => currentCombi.includes(index));\n            const shares = currentCombiShares.map(x => x.value);\n            const indices = currentCombiShares.map(x => x.index);\n            const derivedPrivateKey = this.lagrangeInterpolation(shares, indices);\n            if (!derivedPrivateKey) continue;\n            const decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n            const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n            const decryptedPubKeyY = decryptedPubKey.slice(66);\n\n            if (new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 && new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0) {\n              privateKey = derivedPrivateKey;\n              break;\n            }\n          }\n\n          if (privateKey === undefined || privateKey === null) {\n            throw new Error(\"could not derive private key\");\n          }\n\n          return privateKey;\n        }\n\n        throw new Error(\"invalid\");\n      });\n    }).then(async returnedKey => {\n      let privateKey = returnedKey;\n      if (!privateKey) throw new Error(\"Invalid private key returned\");\n      const decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n      const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n      const decryptedPubKeyY = decryptedPubKey.slice(66);\n      let metadataNonce;\n\n      if (this.enableOneKey) {\n        const {\n          nonce\n        } = await this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey);\n        metadataNonce = new BN(nonce || \"0\", 16);\n      } else {\n        metadataNonce = await this.getMetadata({\n          pub_key_X: decryptedPubKeyX,\n          pub_key_Y: decryptedPubKeyY\n        });\n      }\n\n      log.debug(\"> torus.js/retrieveShares\", {\n        privKey: privateKey.toString(16),\n        metadataNonce: metadataNonce.toString(16)\n      });\n      privateKey = privateKey.add(metadataNonce).umod(this.ec.curve.n);\n      const ethAddress = this.generateAddressFromPrivKey(privateKey);\n      log.debug(\"> torus.js/retrieveShares\", {\n        ethAddress,\n        privKey: privateKey.toString(16)\n      }); // return reconstructed private key and ethereum address\n\n      return {\n        ethAddress,\n        privKey: privateKey.toString(\"hex\", 64),\n        metadataNonce\n      };\n    });\n  }\n\n  async getMetadata(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/get`, data, options, {\n        useAPIKey: true\n      });\n\n      if (!metadataResponse || !metadataResponse.message) {\n        return new BN(0);\n      }\n\n      return new BN(metadataResponse.message, 16); // nonce\n    } catch (error) {\n      log.error(\"get metadata error\", error);\n      return new BN(0);\n    }\n  }\n\n  generateMetadataParams(message, privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64));\n    const setData = {\n      data: message,\n      timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)\n    };\n    const sig = key.sign(keccak256(JsonStringify(setData)).slice(2));\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(\"\").toString(16, 2), \"hex\").toString(\"base64\")\n    };\n  }\n\n  async setMetadata(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/set`, data, options, {\n        useAPIKey: true\n      });\n      return metadataResponse.message; // IPFS hash\n    } catch (error) {\n      log.error(\"set metadata error\", error);\n      return \"\";\n    }\n  }\n\n  lagrangeInterpolation(shares, nodeIndex) {\n    if (shares.length !== nodeIndex.length) {\n      return null;\n    }\n\n    let secret = new BN(0);\n\n    for (let i = 0; i < shares.length; i += 1) {\n      let upper = new BN(1);\n      let lower = new BN(1);\n\n      for (let j = 0; j < shares.length; j += 1) {\n        if (i !== j) {\n          upper = upper.mul(nodeIndex[j].neg());\n          upper = upper.umod(this.ec.curve.n);\n          let temp = nodeIndex[i].sub(nodeIndex[j]);\n          temp = temp.umod(this.ec.curve.n);\n          lower = lower.mul(temp).umod(this.ec.curve.n);\n        }\n      }\n\n      let delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);\n      delta = delta.mul(shares[i]).umod(this.ec.curve.n);\n      secret = secret.add(delta);\n    }\n\n    return secret.umod(this.ec.curve.n);\n  }\n\n  generateAddressFromPrivKey(privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64), \"hex\");\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(publicKey, \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n\n  generateAddressFromPubKey(publicKeyX, publicKeyY) {\n    const key = this.ec.keyFromPublic({\n      x: publicKeyX.toString(\"hex\", 64),\n      y: publicKeyY.toString(\"hex\", 64)\n    });\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(key.getPublic().encode(\"hex\", false), \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n  /**\n   * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n   */\n\n\n  async getPublicAddress(endpoints, torusNodePubs, _ref3) {\n    let {\n      verifier,\n      verifierId\n    } = _ref3;\n    let isExtended = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    log.debug(\"> torus.js/getPublicAddress\", {\n      endpoints,\n      torusNodePubs,\n      verifier,\n      verifierId,\n      isExtended\n    });\n    let finalKeyResult;\n    let isNewKey = false;\n    const {\n      keyResult,\n      errorResult\n    } = (await keyLookup(endpoints, verifier, verifierId)) || {};\n\n    if (errorResult && JSON.stringify(errorResult).includes(\"Verifier not supported\")) {\n      // change error msg\n      throw new Error(`Verifier not supported. Check if you: \\n\n      1. Are on the right network (Torus testnet/mainnet) \\n\n      2. Have setup a verifier on dashboard.web3auth.io?`);\n    } else if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network\n      });\n      const assignResult = await waitKeyLookup(endpoints, verifier, verifierId, 1000);\n      finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n      isNewKey = true;\n    } else if (keyResult) {\n      finalKeyResult = keyResult;\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n\n    log.debug(\"> torus.js/getPublicAddress\", {\n      finalKeyResult,\n      isNewKey\n    });\n\n    if (finalKeyResult) {\n      var _nonce;\n\n      let {\n        pub_key_X: X,\n        pub_key_Y: Y\n      } = finalKeyResult.keys[0];\n      let nonceResult;\n      let nonce;\n      let modifiedPubKey;\n      let typeOfUser;\n      let pubNonce;\n\n      if (this.enableOneKey) {\n        try {\n          nonceResult = await this.getOrSetNonce(X, Y, undefined, !isNewKey);\n          nonce = new BN(nonceResult.nonce || \"0\", 16);\n          typeOfUser = nonceResult.typeOfUser;\n        } catch {\n          throw new GetOrSetNonceError();\n        }\n\n        if (nonceResult.typeOfUser === \"v1\") {\n          modifiedPubKey = this.ec.keyFromPublic({\n            x: X,\n            y: Y\n          }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n        } else if (nonceResult.typeOfUser === \"v2\") {\n          if (nonceResult.upgraded) {\n            // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n            modifiedPubKey = this.ec.keyFromPublic({\n              x: X,\n              y: Y\n            }).getPublic();\n          } else {\n            modifiedPubKey = this.ec.keyFromPublic({\n              x: X,\n              y: Y\n            }).getPublic().add(this.ec.keyFromPublic({\n              x: nonceResult.pubNonce.x,\n              y: nonceResult.pubNonce.y\n            }).getPublic());\n            pubNonce = nonceResult.pubNonce;\n          }\n        } else {\n          throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n        }\n      } else {\n        typeOfUser = \"v1\";\n        nonce = await this.getMetadata({\n          pub_key_X: X,\n          pub_key_Y: Y\n        });\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n      }\n\n      X = modifiedPubKey.getX().toString(16);\n      Y = modifiedPubKey.getY().toString(16);\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n      log.debug(\"> torus.js/getPublicAddress\", {\n        X,\n        Y,\n        address,\n        typeOfUser,\n        nonce: (_nonce = nonce) === null || _nonce === void 0 ? void 0 : _nonce.toString(16),\n        pubNonce\n      });\n      if (!isExtended) return address;\n      return {\n        typeOfUser,\n        address,\n        X,\n        Y,\n        metadataNonce: nonce,\n        pubNonce\n      };\n    }\n\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n  }\n  /**\n   * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n   */\n\n\n  async getOrSetNonce(X, Y, privKey) {\n    let getOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let data;\n    const msg = getOnly ? \"getNonce\" : \"getOrSetNonce\";\n\n    if (privKey) {\n      data = this.generateMetadataParams(msg, privKey);\n    } else {\n      data = {\n        pub_key_X: X,\n        pub_key_Y: Y,\n        set_data: {\n          data: msg\n        }\n      };\n    }\n\n    return post(`${this.metadataHost}/get_or_set_nonce`, data, undefined, {\n      useAPIKey: true\n    });\n  }\n\n  async getNonce(X, Y, privKey) {\n    return this.getOrSetNonce(X, Y, privKey, true);\n  }\n\n  getPostboxKeyFrom1OutOf1(privKey, nonce) {\n    const privKeyBN = new BN(privKey, 16);\n    const nonceBN = new BN(nonce, 16);\n    return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString(\"hex\");\n  }\n\n}\n\nexport { GetOrSetNonceError, Torus as default, kCombinations, keccak256, keyAssign, keyLookup, thresholdSame, waitKeyLookup };","map":{"version":3,"sources":["../src/loglevel.ts","../src/some.ts","../src/utils.ts","../src/torus.ts"],"names":["log","loglevel","str","constructor","predicate","Some","finishedCount","sharedState","resolved","errorArr","promises","resultArr","resp","error","data","resolve","predicateError","errors","acc","capitalizeFirstLetter","msg","it","reject","responses","kCombinations","set","length","k","combs","tailCombs","i","j","thresholdSame","hashMap","arr","JsonStringify","keyLookup","lookupPromises","endpoints","x","generateJsonRPCObject","verifier_id","verifierId","err","lookupResults","lookupShares","x1","errorResult","x2","keyResult","x3","Promise","JSON","waitKeyLookup","setTimeout","keyAssign","network","lastPoint","nodeNum","Math","initialPoint","firstPoint","signedData","post","headers","pubKeyX","torusNodePubs","pubKeyY","useAPIKey","acceptedErrorMsgs","hash","createKeccakHash","enableOneKey","metadataHost","allowHost","signerHost","serverTimeOffset","enableLogging","v","setAPIKey","setEmbedHost","isGetOrSetNonceError","getUserTypeAndAddress","doesKeyAssign","isNewKey","assignResult","finalKeyResult","pub_key_X","pub_key_Y","Y","nonceResult","nonce","modifiedPubKey","y","finalX","finalY","address","typeOfUser","X","pubNonce","upgraded","setCustomKey","customKeyHex","torusKey","privKey","customKey","newMetadataNonce","retrieveShares","extraParams","promiseArr","get","verifierParams","tmpKey","generatePrivate","pubKey","getPublic","tokenCommitment","keccak256","p","messageprefix","tokencommitment","temppubx","temppuby","verifieridentifier","verifier","completedRequests","promiseArrRequest","nodeSigs","encrypted","item","idtoken","nodesignatures","shareResponses","thresholdPublicKey","sharePromises","nodeIndexes","currentShareResponse","a","b","firstKey","metadata","ephemPublicKey","Buffer","iv","mac","decrypt","ciphertext","indexes","sharesResolved","decryptedShares","index","value","allCombis","privateKey","currentCombi","currentCombiShares","shares","indices","derivedPrivateKey","decryptedPubKey","decryptedPubKeyX","decryptedPubKeyY","metadataNonce","ethAddress","getMetadata","options","metadataResponse","generateMetadataParams","key","setData","timestamp","Date","sig","stringify","set_data","signature","setMetadata","lagrangeInterpolation","nodeIndex","secret","upper","lower","temp","delta","generateAddressFromPrivKey","publicKey","ethAddressLower","toChecksumAddress","generateAddressFromPubKey","publicKeyX","publicKeyY","getPublicAddress","isExtended","getOrSetNonce","getOnly","getNonce","getPostboxKeyFrom1OutOf1","privKeyBN","nonceBN"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { generatePrivate, getPublic, decrypt } from '@toruslabs/eccrypto';\nimport { post, generateJsonRPCObject, setAPIKey, setEmbedHost, get } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport JsonStringify from 'json-stable-stringify';\nimport { toChecksumAddress } from 'web3-utils';\nimport loglevel from 'loglevel';\nimport createKeccakHash from 'keccak';\n\nconst log = loglevel.getLogger(\"torus.js\");\nlog.disableAll();\n\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nclass SomeError extends Error {\n  constructor(_ref) {\n    let {\n      errors,\n      responses,\n      predicate\n    } = _ref;\n    super(\"Unable to resolve enough promises.\");\n\n    _defineProperty(this, \"errors\", void 0);\n\n    _defineProperty(this, \"responses\", void 0);\n\n    _defineProperty(this, \"predicate\", void 0);\n\n    this.errors = errors;\n    this.responses = responses;\n    this.predicate = predicate;\n  }\n\n}\nconst Some = (promises, predicate) => new Promise((resolve, reject) => {\n  let finishedCount = 0;\n  const sharedState = {\n    resolved: false\n  };\n  const errorArr = new Array(promises.length).fill(undefined);\n  const resultArr = new Array(promises.length).fill(undefined);\n  let predicateError;\n  return promises.forEach((x, index) => {\n    return x.then(resp => {\n      resultArr[index] = resp;\n      return undefined;\n    }).catch(error => {\n      errorArr[index] = error;\n    }) // eslint-disable-next-line promise/no-return-in-finally\n    .finally(() => {\n      if (sharedState.resolved) return;\n      return predicate(resultArr.slice(0), sharedState).then(data => {\n        sharedState.resolved = true;\n        resolve(data);\n        return undefined;\n      }).catch(error => {\n        // log only the last predicate error\n        predicateError = error;\n      }).finally(() => {\n        finishedCount += 1;\n\n        if (finishedCount === promises.length) {\n          const errors = Object.values(resultArr.reduce((acc, z) => {\n            if (z) {\n              var _error$data;\n\n              const {\n                id,\n                error\n              } = z;\n\n              if ((error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {\n                if (error.data.startsWith(\"Error occurred while verifying params\")) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;\n              }\n            }\n\n            return acc;\n          }, {}));\n\n          if (errors.length > 0) {\n            // Format-able errors\n            const msg = errors.length > 1 ? `\\n${errors.map(it => `â€¢ ${it}`).join(\"\\n\")}` : errors[0];\n            reject(new Error(msg));\n          } else {\n            var _predicateError;\n\n            reject(new SomeError({\n              errors: errorArr,\n              responses: resultArr,\n              predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError\n            }));\n          }\n        }\n      });\n    });\n  });\n});\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass GetOrSetNonceError extends Error {}\nconst kCombinations = (s, k) => {\n  let set = s;\n\n  if (typeof set === \"number\") {\n    set = Array.from({\n      length: set\n    }, (_, i) => i);\n  }\n\n  if (k > set.length || k <= 0) {\n    return [];\n  }\n\n  if (k === set.length) {\n    return [set];\n  }\n\n  if (k === 1) {\n    return set.reduce((acc, cur) => [...acc, [cur]], []);\n  }\n\n  const combs = [];\n  let tailCombs = [];\n\n  for (let i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1);\n\n    for (let j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i], ...tailCombs[j]]);\n    }\n  }\n\n  return combs;\n};\nconst thresholdSame = (arr, t) => {\n  const hashMap = {};\n\n  for (let i = 0; i < arr.length; i += 1) {\n    const str = JsonStringify(arr[i]);\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;\n\n    if (hashMap[str] === t) {\n      return arr[i];\n    }\n  }\n\n  return undefined;\n};\nconst keyLookup = async (endpoints, verifier, verifierId) => {\n  const lookupPromises = endpoints.map(x => post(x, generateJsonRPCObject(\"VerifierLookupRequest\", {\n    verifier,\n    verifier_id: verifierId.toString()\n  })).catch(err => log.error(\"lookup request failed\", err)));\n  return Some(lookupPromises, lookupResults => {\n    const lookupShares = lookupResults.filter(x1 => x1);\n    const errorResult = thresholdSame(lookupShares.map(x2 => x2 && x2.error), ~~(endpoints.length / 2) + 1);\n    const keyResult = thresholdSame(lookupShares.map(x3 => x3 && x3.result), ~~(endpoints.length / 2) + 1);\n\n    if (keyResult || errorResult) {\n      return Promise.resolve({\n        keyResult,\n        errorResult\n      });\n    }\n\n    return Promise.reject(new Error(`invalid results ${JSON.stringify(lookupResults)}`));\n  });\n};\nconst waitKeyLookup = (endpoints, verifier, verifierId, timeout) => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject);\n  }, timeout);\n});\nconst keyAssign = async _ref => {\n  let {\n    endpoints,\n    torusNodePubs,\n    lastPoint,\n    firstPoint,\n    verifier,\n    verifierId,\n    signerHost,\n    network\n  } = _ref;\n  let nodeNum;\n  let initialPoint;\n\n  if (lastPoint === undefined) {\n    nodeNum = Math.floor(Math.random() * endpoints.length);\n    initialPoint = nodeNum;\n  } else {\n    nodeNum = lastPoint % endpoints.length;\n  }\n\n  if (nodeNum === firstPoint) throw new Error(\"Looped through all\");\n  if (firstPoint !== undefined) initialPoint = firstPoint;\n  const data = generateJsonRPCObject(\"KeyAssign\", {\n    verifier,\n    verifier_id: verifierId.toString()\n  });\n\n  try {\n    const signedData = await post(signerHost, data, {\n      headers: {\n        pubKeyX: torusNodePubs[nodeNum].X,\n        pubKeyY: torusNodePubs[nodeNum].Y,\n        network\n      }\n    }, {\n      useAPIKey: true\n    });\n    return await post(endpoints[nodeNum], _objectSpread$1(_objectSpread$1({}, data), signedData), {\n      headers: {\n        \"Content-Type\": \"application/json; charset=utf-8\"\n      }\n    });\n  } catch (error) {\n    log.error(error);\n    const acceptedErrorMsgs = [// Slow node\n    \"Timed out\", // Happens when the node is not reachable (dns issue etc)\n    \"TypeError: Failed to fetch\", \"TypeError: cancelled\", \"TypeError: NetworkError when attempting to fetch resource.\" // Firefox\n    ];\n    if (acceptedErrorMsgs.includes(error.message)) return keyAssign({\n      endpoints,\n      torusNodePubs,\n      lastPoint: nodeNum + 1,\n      firstPoint: initialPoint,\n      verifier,\n      verifierId,\n      signerHost,\n      network\n    });\n    throw new Error(`Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \\n\n    ${error.message || \"\"}`);\n  }\n};\nfunction keccak256(a) {\n  const hash = createKeccakHash(\"keccak256\").update(a).digest().toString(\"hex\");\n  return `0x${hash}`;\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// of Torus nodes to handle malicious node responses\n\nclass Torus {\n  constructor() {\n    let {\n      enableOneKey = false,\n      metadataHost = \"https://metadata.tor.us\",\n      allowHost = \"https://signer.tor.us/api/allow\",\n      signerHost = \"https://signer.tor.us/api/sign\",\n      serverTimeOffset = 0,\n      network = \"mainnet\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _defineProperty(this, \"metadataHost\", void 0);\n\n    _defineProperty(this, \"allowHost\", void 0);\n\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n\n    _defineProperty(this, \"enableOneKey\", void 0);\n\n    _defineProperty(this, \"signerHost\", void 0);\n\n    _defineProperty(this, \"network\", void 0);\n\n    _defineProperty(this, \"ec\", void 0);\n\n    this.ec = new ec(\"secp256k1\");\n    this.metadataHost = metadataHost;\n    this.allowHost = allowHost;\n    this.enableOneKey = enableOneKey;\n    this.serverTimeOffset = serverTimeOffset || 0; // ms\n\n    this.signerHost = signerHost;\n    this.network = network;\n  }\n\n  static enableLogging() {\n    let v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (v) log.enableAll();else log.disableAll();\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n\n  static isGetOrSetNonceError(err) {\n    return err instanceof GetOrSetNonceError;\n  }\n  /**\n   * Note: use this function only for openlogin tkey account lookups.\n   */\n\n\n  async getUserTypeAndAddress(endpoints, torusNodePubs, _ref) {\n    let {\n      verifier,\n      verifierId\n    } = _ref;\n    let doesKeyAssign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      keyResult,\n      errorResult\n    } = (await keyLookup(endpoints, verifier, verifierId)) || {};\n    let isNewKey = false;\n    let finalKeyResult;\n\n    if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n      if (!doesKeyAssign) {\n        throw new Error(\"Verifier + VerifierID has not yet been assigned\");\n      }\n\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network\n      });\n      const assignResult = await waitKeyLookup(endpoints, verifier, verifierId, 1000);\n      finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n      isNewKey = true;\n    } else if (keyResult) {\n      finalKeyResult = keyResult;\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n\n    if (finalKeyResult) {\n      const {\n        pub_key_X: X,\n        pub_key_Y: Y\n      } = finalKeyResult.keys[0];\n      let nonceResult;\n      let nonce;\n      let modifiedPubKey;\n\n      try {\n        nonceResult = await this.getOrSetNonce(X, Y, undefined, !isNewKey);\n        nonce = new BN(nonceResult.nonce || \"0\", 16);\n      } catch {\n        throw new GetOrSetNonceError();\n      }\n\n      if (nonceResult.typeOfUser === \"v1\") {\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n      } else if (nonceResult.typeOfUser === \"v2\") {\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPublic({\n          x: nonceResult.pubNonce.x,\n          y: nonceResult.pubNonce.y\n        }).getPublic());\n      } else {\n        throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n      }\n\n      const finalX = modifiedPubKey.getX().toString(16);\n      const finalY = modifiedPubKey.getY().toString(16);\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n      if (nonceResult.typeOfUser === \"v1\") return {\n        typeOfUser: nonceResult.typeOfUser,\n        nonce,\n        X: finalX,\n        Y: finalY,\n        address\n      };else if (nonceResult.typeOfUser === \"v2\") {\n        return {\n          typeOfUser: nonceResult.typeOfUser,\n          nonce,\n          pubNonce: nonceResult.pubNonce,\n          upgraded: nonceResult.upgraded,\n          X: finalX,\n          Y: finalY,\n          address\n        };\n      }\n    }\n\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n  }\n\n  async setCustomKey(_ref2) {\n    let {\n      privKeyHex,\n      metadataNonce,\n      torusKeyHex,\n      customKeyHex\n    } = _ref2;\n    let torusKey;\n\n    if (torusKeyHex) {\n      torusKey = new BN(torusKeyHex, 16);\n    } else {\n      const privKey = new BN(privKeyHex, 16);\n      torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n);\n    }\n\n    const customKey = new BN(customKeyHex, 16);\n    const newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n);\n    const data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey);\n    await this.setMetadata(data);\n  }\n\n  async retrieveShares(endpoints, indexes, verifier, verifierParams, idToken) {\n    let extraParams = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    const promiseArr = [];\n    await get(this.allowHost, {\n      headers: {\n        verifier,\n        verifier_id: verifierParams.verifier_id,\n        network: this.network\n      }\n    }, {\n      useAPIKey: true\n    });\n    /*\n      CommitmentRequestParams struct {\n        MessagePrefix      string `json:\"messageprefix\"`\n        TokenCommitment    string `json:\"tokencommitment\"`\n        TempPubX           string `json:\"temppubx\"`\n        TempPubY           string `json:\"temppuby\"`\n        VerifierIdentifier string `json:\"verifieridentifier\"`\n      }\n      */\n    // generate temporary private and public key that is used to secure receive shares\n\n    const tmpKey = generatePrivate();\n    const pubKey = getPublic(tmpKey).toString(\"hex\");\n    const pubKeyX = pubKey.slice(2, 66);\n    const pubKeyY = pubKey.slice(66);\n    const tokenCommitment = keccak256(idToken); // make commitment requests to endpoints\n\n    for (let i = 0; i < endpoints.length; i += 1) {\n      const p = post(endpoints[i], generateJsonRPCObject(\"CommitmentRequest\", {\n        messageprefix: \"mug00\",\n        tokencommitment: tokenCommitment.slice(2),\n        temppubx: pubKeyX,\n        temppuby: pubKeyY,\n        verifieridentifier: verifier\n      })).catch(err => {\n        log.error(\"commitment\", err);\n      });\n      promiseArr.push(p);\n    }\n    /*\n      ShareRequestParams struct {\n        Item []bijson.RawMessage `json:\"item\"`\n      }\n      ShareRequestItem struct {\n        IDToken            string          `json:\"idtoken\"`\n        NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n        VerifierIdentifier string          `json:\"verifieridentifier\"`\n      }\n      NodeSignature struct {\n        Signature   string\n        Data        string\n        NodePubKeyX string\n        NodePubKeyY string\n      }\n      CommitmentRequestResult struct {\n        Signature string `json:\"signature\"`\n        Data      string `json:\"data\"`\n        NodePubX  string `json:\"nodepubx\"`\n        NodePubY  string `json:\"nodepuby\"`\n      }\n      */\n    // send share request once k + t number of commitment requests have completed\n\n\n    return Some(promiseArr, resultArr => {\n      const completedRequests = resultArr.filter(x => {\n        if (!x || typeof x !== \"object\") {\n          return false;\n        }\n\n        if (x.error) {\n          return false;\n        }\n\n        return true;\n      });\n\n      if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n        return Promise.resolve(resultArr);\n      }\n\n      return Promise.reject(new Error(`invalid ${JSON.stringify(resultArr)}`));\n    }).then(responses => {\n      const promiseArrRequest = [];\n      const nodeSigs = [];\n\n      for (let i = 0; i < responses.length; i += 1) {\n        if (responses[i]) nodeSigs.push(responses[i].result);\n      }\n\n      for (let i = 0; i < endpoints.length; i += 1) {\n        // eslint-disable-next-line promise/no-nesting\n        const p = post(endpoints[i], generateJsonRPCObject(\"ShareRequest\", {\n          encrypted: \"yes\",\n          item: [_objectSpread(_objectSpread({}, verifierParams), {}, {\n            idtoken: idToken,\n            nodesignatures: nodeSigs,\n            verifieridentifier: verifier\n          }, extraParams)]\n        })).catch(err => log.error(\"share req\", err));\n        promiseArrRequest.push(p);\n      }\n\n      return Some(promiseArrRequest, async (shareResponses, sharedState) => {\n        /*\n            ShareRequestResult struct {\n              Keys []KeyAssignment\n            }\n                    / KeyAssignmentPublic -\n            type KeyAssignmentPublic struct {\n              Index     big.Int\n              PublicKey common.Point\n              Threshold int\n              Verifiers map[string][]string // Verifier => VerifierID\n            }\n                   // KeyAssignment -\n            type KeyAssignment struct {\n              KeyAssignmentPublic\n              Share big.Int // Or Si\n            }\n          */\n        // check if threshold number of nodes have returned the same user public key\n        const completedRequests = shareResponses.filter(x => x);\n        const thresholdPublicKey = thresholdSame(shareResponses.map(x => x && x.result && x.result.keys[0].PublicKey), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received\n        // this is matched against the user public key to ensure that shares are consistent\n\n        if (completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey) {\n          const sharePromises = [];\n          const nodeIndexes = [];\n\n          for (let i = 0; i < shareResponses.length; i += 1) {\n            var _currentShareResponse, _currentShareResponse2;\n\n            const currentShareResponse = shareResponses[i];\n\n            if ((currentShareResponse === null || currentShareResponse === void 0 ? void 0 : (_currentShareResponse = currentShareResponse.result) === null || _currentShareResponse === void 0 ? void 0 : (_currentShareResponse2 = _currentShareResponse.keys) === null || _currentShareResponse2 === void 0 ? void 0 : _currentShareResponse2.length) > 0) {\n              currentShareResponse.result.keys.sort((a, b) => new BN(a.Index, 16).cmp(new BN(b.Index, 16)));\n              const firstKey = currentShareResponse.result.keys[0];\n\n              if (firstKey.Metadata) {\n                const metadata = {\n                  ephemPublicKey: Buffer.from(firstKey.Metadata.ephemPublicKey, \"hex\"),\n                  iv: Buffer.from(firstKey.Metadata.iv, \"hex\"),\n                  mac: Buffer.from(firstKey.Metadata.mac, \"hex\") // mode: Buffer.from(firstKey.Metadata.mode, \"hex\"),\n\n                };\n                sharePromises.push( // eslint-disable-next-line promise/no-nesting\n                decrypt(tmpKey, _objectSpread(_objectSpread({}, metadata), {}, {\n                  ciphertext: Buffer.from(Buffer.from(firstKey.Share, \"base64\").toString(\"binary\").padStart(64, \"0\"), \"hex\")\n                })).catch(err => log.debug(\"share decryption\", err)));\n              } else {\n                sharePromises.push(Promise.resolve(Buffer.from(firstKey.Share.padStart(64, \"0\"), \"hex\")));\n              }\n            } else {\n              sharePromises.push(Promise.resolve(undefined));\n            }\n\n            nodeIndexes.push(new BN(indexes[i], 16));\n          }\n\n          const sharesResolved = await Promise.all(sharePromises);\n          if (sharedState.resolved) return undefined;\n          const decryptedShares = sharesResolved.reduce((acc, curr, index) => {\n            if (curr) acc.push({\n              index: nodeIndexes[index],\n              value: new BN(curr)\n            });\n            return acc;\n          }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n\n          const allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);\n          let privateKey = null;\n\n          for (let j = 0; j < allCombis.length; j += 1) {\n            const currentCombi = allCombis[j];\n            const currentCombiShares = decryptedShares.filter((v, index) => currentCombi.includes(index));\n            const shares = currentCombiShares.map(x => x.value);\n            const indices = currentCombiShares.map(x => x.index);\n            const derivedPrivateKey = this.lagrangeInterpolation(shares, indices);\n            if (!derivedPrivateKey) continue;\n            const decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n            const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n            const decryptedPubKeyY = decryptedPubKey.slice(66);\n\n            if (new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 && new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0) {\n              privateKey = derivedPrivateKey;\n              break;\n            }\n          }\n\n          if (privateKey === undefined || privateKey === null) {\n            throw new Error(\"could not derive private key\");\n          }\n\n          return privateKey;\n        }\n\n        throw new Error(\"invalid\");\n      });\n    }).then(async returnedKey => {\n      let privateKey = returnedKey;\n      if (!privateKey) throw new Error(\"Invalid private key returned\");\n      const decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n      const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n      const decryptedPubKeyY = decryptedPubKey.slice(66);\n      let metadataNonce;\n\n      if (this.enableOneKey) {\n        const {\n          nonce\n        } = await this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey);\n        metadataNonce = new BN(nonce || \"0\", 16);\n      } else {\n        metadataNonce = await this.getMetadata({\n          pub_key_X: decryptedPubKeyX,\n          pub_key_Y: decryptedPubKeyY\n        });\n      }\n\n      log.debug(\"> torus.js/retrieveShares\", {\n        privKey: privateKey.toString(16),\n        metadataNonce: metadataNonce.toString(16)\n      });\n      privateKey = privateKey.add(metadataNonce).umod(this.ec.curve.n);\n      const ethAddress = this.generateAddressFromPrivKey(privateKey);\n      log.debug(\"> torus.js/retrieveShares\", {\n        ethAddress,\n        privKey: privateKey.toString(16)\n      }); // return reconstructed private key and ethereum address\n\n      return {\n        ethAddress,\n        privKey: privateKey.toString(\"hex\", 64),\n        metadataNonce\n      };\n    });\n  }\n\n  async getMetadata(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/get`, data, options, {\n        useAPIKey: true\n      });\n\n      if (!metadataResponse || !metadataResponse.message) {\n        return new BN(0);\n      }\n\n      return new BN(metadataResponse.message, 16); // nonce\n    } catch (error) {\n      log.error(\"get metadata error\", error);\n      return new BN(0);\n    }\n  }\n\n  generateMetadataParams(message, privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64));\n    const setData = {\n      data: message,\n      timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)\n    };\n    const sig = key.sign(keccak256(JsonStringify(setData)).slice(2));\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(\"\").toString(16, 2), \"hex\").toString(\"base64\")\n    };\n  }\n\n  async setMetadata(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/set`, data, options, {\n        useAPIKey: true\n      });\n      return metadataResponse.message; // IPFS hash\n    } catch (error) {\n      log.error(\"set metadata error\", error);\n      return \"\";\n    }\n  }\n\n  lagrangeInterpolation(shares, nodeIndex) {\n    if (shares.length !== nodeIndex.length) {\n      return null;\n    }\n\n    let secret = new BN(0);\n\n    for (let i = 0; i < shares.length; i += 1) {\n      let upper = new BN(1);\n      let lower = new BN(1);\n\n      for (let j = 0; j < shares.length; j += 1) {\n        if (i !== j) {\n          upper = upper.mul(nodeIndex[j].neg());\n          upper = upper.umod(this.ec.curve.n);\n          let temp = nodeIndex[i].sub(nodeIndex[j]);\n          temp = temp.umod(this.ec.curve.n);\n          lower = lower.mul(temp).umod(this.ec.curve.n);\n        }\n      }\n\n      let delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);\n      delta = delta.mul(shares[i]).umod(this.ec.curve.n);\n      secret = secret.add(delta);\n    }\n\n    return secret.umod(this.ec.curve.n);\n  }\n\n  generateAddressFromPrivKey(privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64), \"hex\");\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(publicKey, \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n\n  generateAddressFromPubKey(publicKeyX, publicKeyY) {\n    const key = this.ec.keyFromPublic({\n      x: publicKeyX.toString(\"hex\", 64),\n      y: publicKeyY.toString(\"hex\", 64)\n    });\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(key.getPublic().encode(\"hex\", false), \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n  /**\n   * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n   */\n\n\n  async getPublicAddress(endpoints, torusNodePubs, _ref3) {\n    let {\n      verifier,\n      verifierId\n    } = _ref3;\n    let isExtended = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    log.debug(\"> torus.js/getPublicAddress\", {\n      endpoints,\n      torusNodePubs,\n      verifier,\n      verifierId,\n      isExtended\n    });\n    let finalKeyResult;\n    let isNewKey = false;\n    const {\n      keyResult,\n      errorResult\n    } = (await keyLookup(endpoints, verifier, verifierId)) || {};\n\n    if (errorResult && JSON.stringify(errorResult).includes(\"Verifier not supported\")) {\n      // change error msg\n      throw new Error(`Verifier not supported. Check if you: \\n\n      1. Are on the right network (Torus testnet/mainnet) \\n\n      2. Have setup a verifier on dashboard.web3auth.io?`);\n    } else if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network\n      });\n      const assignResult = await waitKeyLookup(endpoints, verifier, verifierId, 1000);\n      finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n      isNewKey = true;\n    } else if (keyResult) {\n      finalKeyResult = keyResult;\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n\n    log.debug(\"> torus.js/getPublicAddress\", {\n      finalKeyResult,\n      isNewKey\n    });\n\n    if (finalKeyResult) {\n      var _nonce;\n\n      let {\n        pub_key_X: X,\n        pub_key_Y: Y\n      } = finalKeyResult.keys[0];\n      let nonceResult;\n      let nonce;\n      let modifiedPubKey;\n      let typeOfUser;\n      let pubNonce;\n\n      if (this.enableOneKey) {\n        try {\n          nonceResult = await this.getOrSetNonce(X, Y, undefined, !isNewKey);\n          nonce = new BN(nonceResult.nonce || \"0\", 16);\n          typeOfUser = nonceResult.typeOfUser;\n        } catch {\n          throw new GetOrSetNonceError();\n        }\n\n        if (nonceResult.typeOfUser === \"v1\") {\n          modifiedPubKey = this.ec.keyFromPublic({\n            x: X,\n            y: Y\n          }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n        } else if (nonceResult.typeOfUser === \"v2\") {\n          if (nonceResult.upgraded) {\n            // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n            modifiedPubKey = this.ec.keyFromPublic({\n              x: X,\n              y: Y\n            }).getPublic();\n          } else {\n            modifiedPubKey = this.ec.keyFromPublic({\n              x: X,\n              y: Y\n            }).getPublic().add(this.ec.keyFromPublic({\n              x: nonceResult.pubNonce.x,\n              y: nonceResult.pubNonce.y\n            }).getPublic());\n            pubNonce = nonceResult.pubNonce;\n          }\n        } else {\n          throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n        }\n      } else {\n        typeOfUser = \"v1\";\n        nonce = await this.getMetadata({\n          pub_key_X: X,\n          pub_key_Y: Y\n        });\n        modifiedPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n      }\n\n      X = modifiedPubKey.getX().toString(16);\n      Y = modifiedPubKey.getY().toString(16);\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n      log.debug(\"> torus.js/getPublicAddress\", {\n        X,\n        Y,\n        address,\n        typeOfUser,\n        nonce: (_nonce = nonce) === null || _nonce === void 0 ? void 0 : _nonce.toString(16),\n        pubNonce\n      });\n      if (!isExtended) return address;\n      return {\n        typeOfUser,\n        address,\n        X,\n        Y,\n        metadataNonce: nonce,\n        pubNonce\n      };\n    }\n\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n  }\n  /**\n   * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n   */\n\n\n  async getOrSetNonce(X, Y, privKey) {\n    let getOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let data;\n    const msg = getOnly ? \"getNonce\" : \"getOrSetNonce\";\n\n    if (privKey) {\n      data = this.generateMetadataParams(msg, privKey);\n    } else {\n      data = {\n        pub_key_X: X,\n        pub_key_Y: Y,\n        set_data: {\n          data: msg\n        }\n      };\n    }\n\n    return post(`${this.metadataHost}/get_or_set_nonce`, data, undefined, {\n      useAPIKey: true\n    });\n  }\n\n  async getNonce(X, Y, privKey) {\n    return this.getOrSetNonce(X, Y, privKey, true);\n  }\n\n  getPostboxKeyFrom1OutOf1(privKey, nonce) {\n    const privKeyBN = new BN(privKey, 16);\n    const nonceBN = new BN(nonce, 16);\n    return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString(\"hex\");\n  }\n\n}\n\nexport { GetOrSetNonceError, Torus as default, kCombinations, keccak256, keyAssign, keyLookup, thresholdSame, waitKeyLookup };\n//# sourceMappingURL=torusUtils.esm.js.map\n"]},"metadata":{},"sourceType":"module"}